<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记 on Terminal</title>
    <link>https://caiwp.github.io/tags/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on Terminal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 12 Nov 2019 10:25:55 +0800</lastBuildDate>
    
	<atom:link href="https://caiwp.github.io/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang整数范围</title>
      <link>https://caiwp.github.io/post/golang%E6%95%B4%E6%95%B0%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Tue, 12 Nov 2019 10:25:55 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/golang%E6%95%B4%E6%95%B0%E8%8C%83%E5%9B%B4/</guid>
      <description>参考链接 https://stackoverflow.com/questions/6878590/the-maximum-value-for-an-int-type-in-go
https://groups.google.com/group/golang-nuts/msg/71c307e4d73024ce?pli=1
The germane part:
 Since integer types use two&amp;rsquo;s complement arithmetic, you can infer the min/max constant values for int and uint. For example,
&amp;gt; const MaxUint = ^uint(0) &amp;gt; const MinUint = 0 &amp;gt; const MaxInt = int(MaxUint &amp;gt;&amp;gt; 1) &amp;gt; const MinInt = -MaxInt - 1 &amp;gt; ``` As per @CarelZA&#39;s comment:  golang uint8 : 0 to 255 uint16 : 0 to 65535 uint32 : 0 to 4294967295 uint64 : 0 to 18446744073709551615 int8 : -128 to 127 int16 : -32768 to 32767 int32 : -2147483648 to 2147483647 int64 : -9223372036854775808 to 9223372036854775807 ```</description>
    </item>
    
    <item>
      <title>Golang数组复制</title>
      <link>https://caiwp.github.io/post/golang%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Thu, 07 Nov 2019 10:44:54 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/golang%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6/</guid>
      <description>参考链接 https://www.geeksforgeeks.org/how-to-copy-an-array-into-another-array-in-golang/
// creating a copy of an array by value arr := arr1 // Creating a copy of an array by reference arr := &amp;amp;arr1  两种方式结果不一样，第一种原值不变，第二种会导致原值也跟着改变</description>
    </item>
    
    <item>
      <title>Linux命令sort</title>
      <link>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4sort/</link>
      <pubDate>Tue, 05 Nov 2019 15:45:00 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4sort/</guid>
      <description>参考链接 https://www.cnblogs.com/coderchuanyu/p/4194211.html
忽略相同行使用-u选项或者uniq
只显示单一行： uniq -u file.txt sort file.txt | uniq -u 统计各行在文件中出现的次数： sort file.txt | uniq -c 在文件中找出重复的行： sort file.txt | uniq -d  </description>
    </item>
    
    <item>
      <title>Linux命令awk</title>
      <link>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4awk/</link>
      <pubDate>Tue, 05 Nov 2019 15:44:55 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4awk/</guid>
      <description>参考链接 https://www.runoob.com/linux/linux-comm-awk.html
每行按空格或TAB分割，输出文本中的1、4项 awk &#39;{print $1,$4}&#39; log.txt 使用&amp;quot;,&amp;quot;分割 awk -F, &#39;{print $1,$2}&#39; log.txt if 条件 awk &#39;{if ($1==1) print &amp;quot;A&amp;quot;; else if ($1==2) print &amp;quot;B&amp;quot;; else print &amp;quot;C&amp;quot;}&#39;  </description>
    </item>
    
    <item>
      <title>Linux命令pkill</title>
      <link>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4pkill/</link>
      <pubDate>Fri, 01 Nov 2019 15:47:45 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4pkill/</guid>
      <description>https://man.linuxde.net/pkill
pkill命令可以按照进程名杀死进程。会全部杀掉。
pkill (选项) (参数) -o：仅向找到的最小（起始）进程号发送信号； -n：仅向找到的最大（结束）进程号发送信号； -P：指定父进程号发送信号； -g：指定进程组； -t：指定开启进程的终端。  </description>
    </item>
    
    <item>
      <title>Linux命令pgrep</title>
      <link>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4pgrep/</link>
      <pubDate>Fri, 01 Nov 2019 15:30:37 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/linux%E5%91%BD%E4%BB%A4pgrep/</guid>
      <description>https://man.linuxde.net/pgrep
pgrep (选项) (参数) -o：仅显示找到的最小（起始）进程号； -n：仅显示找到的最大（结束）进程号； -l：显示进程名称； -P：指定父进程号； -g：指定进程组； -t：指定开启进程的终端； -u：指定进程的有效用户ID。  </description>
    </item>
    
    <item>
      <title>Mysql创建用户</title>
      <link>https://caiwp.github.io/post/mysql%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7/</link>
      <pubDate>Thu, 31 Oct 2019 17:53:45 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/mysql%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7/</guid>
      <description>https://www.cnblogs.com/chanshuyi/p/mysql_user_mng.html
创建用户 create user zhangsan identified by &#39;zhangsan&#39;; 开权限 grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;; flush privileges; 查看权限 show grants for &#39;zhangsan&#39;; 更新密码 update mysql.user set password = password(&#39;zhangsannew&#39;) where user = &#39;zhangsan&#39; and host = &#39;%&#39;; flush privileges; 删除用户 drop user zhangsan@&#39;%&#39;;  </description>
    </item>
    
    <item>
      <title>Go比较float</title>
      <link>https://caiwp.github.io/post/go%E6%AF%94%E8%BE%83float/</link>
      <pubDate>Thu, 31 Oct 2019 16:11:19 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/go%E6%AF%94%E8%BE%83float/</guid>
      <description> 直接比较是会有坑，需要进行减去取绝对值的有效范围如
func almostEqual(a, b float64) bool { return math.Abs(a-b) &amp;lt;= 0.001 }   </description>
    </item>
    
    <item>
      <title>Golang 利用 pprof 定位问题</title>
      <link>https://caiwp.github.io/post/golang%E5%88%A9%E7%94%A8pprof%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 30 Oct 2019 15:40:45 +0800</pubDate>
      
      <guid>https://caiwp.github.io/post/golang%E5%88%A9%E7%94%A8pprof%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</guid>
      <description>在代码中引入 _ &amp;ldquo;net/http/pprof&amp;rdquo; 并监听 http 服务后
通过终端查看 go tool pprof http://127.0.0.1:9191/debug/pprof/heap 通过浏览器查看 http://127.0.0.1:9191/debug/pprof/  </description>
    </item>
    
  </channel>
</rss>